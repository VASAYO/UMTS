function [Flag_isOk, BCCH] = Decode_BCCH(Coded_BCCH) 
% Функция выполняет по-2-ух-кадровое декодирование данных вещательного 
% канала. 
% 
% Входные переменные: 
%   Coded_BCCH - массив-строка (длина кратна 270), содержащий значения 
%                бит всех считанных кадров канала BCCH. 
% 
% Выходные переменные: 
%   BCCH      – массив с количеством строк, равным количеству декодирован- 
%               ых транспортных блоков BCCH, и количеством столбцов 246; 
%   Flag_isOk - указывает на то, был ли успешно декодирован хотя бы один 
%               транспортный блок BCCH.

% Последовательность действий:
%   1. Разбить на блоки по 270 бит;
%   2. Каждый блок - деперемежение;
%   3. Объединение деперемеженных блоков в блоки по 570 бит;
%   4. Деперемежение получившихся блоков;
%   5. Выравнивание скоростей
%   6. Декодирование по алгоритму Витерби;
%   7. Отбрасывание хвоста и проверка CRC.

% Флаг, указывающий на то, сошлось ли CRC хотя бы для одного транспортного
% блока
    isCRCCorrect = false;

% Выбираем из потока блоки по 540 бит с шагом 270 бит и обрабатываем их до
% тех пор, пока не сойдется CRC
    Pos = 1;

    while ~isCRCCorrect        
        % Если обрабатывать больше нечего, то выводим флаг о неудаче
        % ...

        % Выбираем очередной блок бит длиной 540
            CurrentBlock = Coded_BCCH((1:540) + (Pos-1)*270);

        % Разбиваем блок на менее крупные блоки по 270 бит
            Blocks270 = reshape(CurrentBlock, 270, 2); % Блоки по 270 
                                                       % расположены по 
                                                       % столбцам
       % Деперемежение блоков по 270
            Blocks270DeInt = zeros(size(Blocks270));
            Blocks270DeInt(:, 1) = Second_DeInterleaver(Blocks270(:, 1)')';
            Blocks270DeInt(:, 2) = Second_DeInterleaver(Blocks270(:, 2)')';

        % Объединение деперемежённых блоков
            Block540 = Blocks270DeInt(:)';

        % Повторное деперемежение
            Block540DeInt = First_DeInterleaver(Block540, 2);

        % Декодирование алгоритмом Витерби
            DecodedBlock = Convolutional_Decoder(Block540DeInt, 1);

        % Отбрасывание хвоста и проверка CRC
            [isCRCCorrect, Buf] = Check_CRC(DecodedBlock(1:end-8), 16);

        % Если CRC не сошлось, увеличиваем позицию указателя и обрабатывам
        % следующий блок со смещением на 270 бит вперед
            if ~isCRCCorrect
                Pos = Pos+1;
            else
                BCCH = Buf;
            end
    end

1;